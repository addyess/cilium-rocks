name: Build Rocks

on:
  workflow_call:
    inputs:
      image-build-args:
        description: |
          List of build args to pass to the build image job
        type: string
        default: ""
      registry:
        description: Container Registrying top-level domain
        type: string
        default: ghcr.io
      trivy-image-config:
        type: string
        description: Trivy YAML configuration for image testing that is checked in as part of the repo
      working-directory:
        type: string
        description: The working directory for jobs
        default: "./"
        
jobs:
  get-runner-image:
    name: Get runner image
    uses: canonical/operator-workflows/.github/workflows/get_runner_image.yaml@main
    with:
      working-directory: ${{ inputs.working-directory }}
  build-rocks:
    name: Build rocks
    uses: addyess/operator-workflows/.github/workflows/build_rocks.yaml@KU-52-reuse-gh-actions-from-canonical-to-build-amd-64-rocks-and-push-to-ghcr
    needs: [get-runner-image]
    with:
      owner: ${{ github.repository_owner }}
      registry: ${{ inputs.registry }}
      runs-on: ${{ needs.get-runner-image.outputs.runs-on }}
      trivy-image-config: ${{ inputs.trivy-image-config }}
      working-directory: ${{ inputs.working-directory }}
      multiarch-awareness: true
  create-multiarch-manifest:
    name: Create Mulitarch Manifest
    needs: [build-rocks]
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4.1.1
    - name: Assemble Image Tags
      id: assemble-image-tags
      uses: actions/github-script@v7.0.1
      with:
        script: |
          async function get_containers(org, package_name) {
            let containers;
            core.info(`Looking up existing containers ${org}/${package_name}`)
            try {
                containers = (await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                    org,
                    package_type: "container",
                    package_name,
                })).data;
            } catch (e) {
                containers = [];
                console.error(e);
            }
            return containers
          }

          const path = require('path')
          const inputs = ${{ toJSON(inputs) }}
          const registry = inputs.registry
          const owner = context.repo.owner
          const metas = await Promise.all(
            JSON.parse(`${{ needs.build-rocks.outputs.rock-metas }}`).map(
              async meta => {
                const versions = await get_containers(owner, meta.name)
                const rockVersion_ = meta.version + "-ck"
                const patchRev = versions.reduce((partial, v) =>
                  partial + v.metadata.container.tags.filter(t => t.startsWith(rockVersion_)).length, 0
                )
                core.info(`Number of containers tagged ${owner}/${meta.name}/${meta.version}: ${patchRev}`)
                meta.version = rockVersion_ + patchRev
                core.info(`Tagging image ${meta.image} with ${meta.version}`)
                return meta
              }
            )
          )
          core.setOutput('rock-metas', JSON.stringify(metas))
    - name: Login to Container Registry
      uses: docker/login-action@v3.0.0
      with:
        registry: ${{ inputs.registry }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Create and Push Manifests
      id: create-and-push-manifest
      uses: actions/github-script@v7.0.1
      with:
        script: |
          class RockImage {
            constructor (image, arch) {
              this.image = image
              this.arch = arch
            }
           
            async import_image() {
              console.info(`    ‚è¨ pull image: ${this.image}`)
              await exec.exec("docker", ["pull", this.image])
            }

            async annotate(image) {
              console.info(`    üñåÔ∏è annotate manifest: ${image} ${this.arch}`)
              await exec.exec("docker", ["manifest", "annotate", image, this.image, `--arch=${this.arch}`])
            }
          }

          class RockComponent {
            constructor (name, version) {
              this.name = name
              this.version = version
              this.imageVer = `${this.name}:${this.version}`
              this.images = []
            }

            async create_manifest(target) {
              const archs = this.images.map(i => i.arch)
              const rocks = this.images.map(i => i.image)
              console.info(`  üìÑ create manifest: ${target} ${archs.join(",")}`)
              await exec.exec("docker", ["manifest", "create", target, rocks.join(' ')])
            }

            async push_manifest(target) {
              console.info(`  ‚è´ push manifest: ${target}`)
              console.info(`docker manifest push ${target}`)
              await exec.exec("docker", ["manifest", "push", target])
            }

            async craft_manifest(target) {
              for (const image of this.images) {
                await image.import_image()
              }
              const targetImage = `${target.trim('/')}/${this.imageVer}`
              await exec.exec("docker", ["manifest", "rm", targetImage], {ignoreReturnCode: true})
              await this.create_manifest(targetImage)

              for (const image of this.images) {
                  await image.annotate(targetImage)
              }
              await this.push_manifest(targetImage)
            }
          }

          async function main() {
            const inputs = ${{ toJSON(inputs) }}
            const registry = inputs.registry
            const owner = '${{ github.repository_owner }}'
            const metas = JSON.parse(`${{ steps.assemble-image-tags.outputs.rock-metas }}`)
            const containers = {}
            for (const meta of metas) {
              if (!containers.hasOwnProperty(meta.name)) {
                containers[meta.name] = new RockComponent(meta.name, meta.version)
              }
              containers[meta.name].images.push(new RockImage(meta.image, meta.arch))
            }
            for (const component of Object.values(containers)) {
              console.info(`üñ•Ô∏è  Assemble Multiarch Image: ${component.name}`)
              await component.craft_manifest(`${registry}/${owner}`)
            }
          }

          await main()
