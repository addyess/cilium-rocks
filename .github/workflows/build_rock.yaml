name: Build Rocks

on:
  workflow_call:
    inputs:
      image-build-args:
        description: |
          List of build args to pass to the build image job
        type: string
        default: ""
      registry:
        description: Container Registrying top-level domain
        type: string
        default: ghcr.io
      trivy-image-config:
        type: string
        description: Trivy YAML configuration for image testing that is checked in as part of the repo
      working-directory:
        type: string
        description: The working directory for jobs
        default: "./"
        
jobs:
  get-runner-image:
    name: Get runner image
    uses: canonical/operator-workflows/.github/workflows/get_runner_image.yaml@main
    with:
      working-directory: ${{ inputs.working-directory }}
  build-rocks:
    name: Build rocks
    uses: addyess/operator-workflows/.github/workflows/build_rocks.yaml@KU-52-reuse-gh-actions-from-canonical-to-build-amd-64-rocks-and-push-to-ghcr
    needs: get-runner-image
    with:
      owner: ${{ github.repository_owner }}
      registry: ${{ inputs.registry }}
      runs-on: ${{ needs.get-runner-image.outputs.runs-on }}
      trivy-image-config: ${{ inputs.trivy-image-config }}
      working-directory: ${{ inputs.working-directory }}
      multiarch-awareness: true
  create-multiarch-manifest:
    name: Create Mulitarch Manifest
    needs: build-rocks
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4.1.1
    - name: Assemble Image Tags
      id: assemble-image-tags
      uses: actions/github-script@v7.0.1
      with:
        script: |
          const path = require('path')
          const owner = '${{ github.repository_owner }}'
          const registry = core.getInput('registry')
          const workingDir = core.getInput('working-directory')
          const meta = JSON.parse(`${{ steps.build-rocks.outputs.rock-metas }}`)

          const imageManifests = []
          for (const meta of metas) {
            core.info(`loading rockcraft.yaml in ${rockPath}`)
            const rockcraftFile = path.join([workingDir, meta.path, 'rockcraft.yaml'])
            const [rockName, rockVersion] = (
              await exec.getExecOutput('yq', ['.name,.version', rockcraftFile])
            ).stdout.trim().split("\n")
            const versions = github.rest.packages.getAllPackageVersionsForAPackageOwnedByAnOrg(
              'container', rockName, owner
            )
            const rockVersion_ = rockVersion + "-ck"
            var patchRev = 0
            for (const version of versions) {
              for (const tag of version.metadata.container.tags) {
                if (tag.startsWith(rockVersion_)) {
                  patchRev += 1;
                }
              }
            }
            meta.name = rockName
            meta.version = rockVersion_ + patchRev
            core.info(`Tagging image ${meta.image} with ${meta.version}`)
          }
          core.setOutput('rock-metas', JSON.stringify(meta))
    - name: Create and Push Manifests
      id: create-and-push-manifest
      uses: actions/github-script@7.0.1
      with:
        script: |
          class RockImage {
            constructor (rock, arch) {
              this.rock = rock
              this.arch = arch
            }
            
            import_image = (image) => {
              console.log("    ü™®  import image: %s", this.rock)
              runner(`docker pull ${this.rock}`)
            }
            
            annotate = (image) => {
              console.info(`    üñåÔ∏è annotate manifest: ${image} ${this.arch}`)
              runner(`docker manifest annotate ${image} ${this.rock} --arch=${this.arch}`)
            }
          }

          class RockComponent {
            constructor (name, version) {
              this.imageName = name
              this.version = version
              this.imageVer = `${this.imageName}:${this.version}`
              this.images = []
            }

            create_manifest = (target) => {
              var archs = this.images.map(i => i.arch)
              var rocks = this.images.map(i => i.rock)
              var amends = rocks.map(r => `--amend ${r}`)
              console.log(`  üìÑ create manifest: ${target} ${archs.join(",")}`)
              runner(`docker manifest create ${target} ${amends.join(' ')}`)
            }

            push_manifest = (target) => {
              console.log("  ‚è´ push manifest: %s", target)
              runner(`docker manifest push ${target}`)
            }

            craft_manifest = (target) => {
              var targetImage = `${target.trim('/')}/${this.imageVer}`
              runner(`docker manifest rm ${targetImage}`)

              console.log(`  üèÅ Start Rock Uploads: ${this.imageName}` )
              for (const image of this.images) {
                  image.import_image(targetImage)
              }

              this.create_manifest(targetImage)

              for (const image of this.images) {
                  image.annotate(targetImage)
              }
              this.push_manifest(targetImage)
            }
          }

          function runner(command) {
            console.log(`              > ${command}`)
          }


          function main() {
            const registry = core.getInput('registry')
            const owner = '${{ github.repository_owner }}'
            const metas = JSON.parse(`${{ steps.assemble-image-tags.outputs.rock-metas }}`)
            const containers = {}
            for (const meta of metas) {
              if (!containers.hasOwnProperty(meta.name)) {
                containers[meta.name] = new RockComponent(meta.name, meta.version)
              }
              containers[meta.name].images.push(new RockImage(meta.image, meta.arch))
            }
            for (const component of Object.values(containers)) {
              console.log("üñ•Ô∏è  Assemble Multiarch Image: %s", component.imageName)
              component.craft_manifest(`${registry}/${owner}`)
            }
          }

          main()
